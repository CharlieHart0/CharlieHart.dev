[{"content":"This project was my postgraduate dissertation project, titled \u0026lsquo;Realtime Soft Body Simulation using a Spring-Mass approach\u0026rsquo;. This post can be considered a condensed summary of the dissertation document, and more detailed information can be found at the following link:\nThe Dissertation document can be found here\nSoft bodies are physically simulated objects capable of deformation - changing shape in response to forces experienced. Most physical objects in computer simulations are rigid bodies, which do not experience deformation, but soft body physics systems are required in order to simulate complex structures in a physically accurate way, such as clothing.\nIn this project, different approaches to soft body physics were investigated, before one was chosen and implemented, alongside a system to render the deformable objects in real time.\nThe implemented systems were then tested, and results showed that at least 64 cube shaped soft bodies were able to be simulated simultaneously, and that the dynamic mesh rendering method used to render deforming meshes was able to render 64 soft bodies in real time at 75.8 frames per second.\nVideo Screenshots Motion of simulated objects like these softbodies can be difficult to show in still images, so I reccommend watching the video above!\nDevelopment / Implementation Physics The soft body simulation approach chosen was the spring-mass approach, where point masses are constrained by a network of spring constraints.\nThe spring constraints implemented acted as both compression and extension springs, where the difference between the current distance between points, and the resting position between the points, is proportional to the force applied to both points in order to return them to the resting position. The spring constant is the value used for this proportional relationship, in force units per distance units.\nAdditionally, a damping factor is used to limit the energy in the system. Depending on how aligned the velocities of the point masses are to the line passing between them, a small force acting against the spring\u0026rsquo;s force is applied, in order to prevent a runaway system being supplied more and more energy from gravity without any energy sink in this ideal simulation, lacking air resistance or the loss of thermal energy from a material being deformed.\nPoint masses were created at each vertex of a polygonal mesh, and spring constraints were generated between points at the location of each edge on the mesh, with the resting length of each spring set to the distance between the two vertices. The desired total mass of the softbody object and the number of point masses generated is used to equally distribute the mass among the points.\nStability As most polygonal meshes are not designed to be used in this way, they can often be unstable, with edges between vertices unable to form a semi-rigid structure in the desired shape, and deforming into a more stable configuration. This was particularly notable in concave meshes, where overhangs would fold into the object to become more stable.\nWith most simple convex meshes, stability could be achieved by adding springs between vertices that create coplanar faces.\nRendering The existing rendering system used in the engine was not capable of rendering deformable meshes - only skeletal animation was able to move vertices relative to one another, which was not appropriate for soft body objects, able to deform in many different ways, according to the physics system, separate from the GPU.\nTwo methods of rendering the softbodies were used, a wireframe rendering approach, mainly used during development and testing of the physics portion of the project, and a second method, in which a new mesh was generated and uploaded to the GPU for each softbody, every frame, along with calculating the normals of each face\u0026rsquo;s new location, scale and orientation.\nThis second method is far from ideal, as sending a new mesh from the CPU to the GPU potentially hundreds or thousands of times per frame would be very slow. Improvements are suggested in the further work section below.\nResults As shown in the YouTube video at the top of the page, tests were carried out using an increasing number of softbody objects each time, until unexpected behaviour occurred.\nPhysics Regardless of the rendering method used, the physics simulation began to behave unexpectedly at around 80 objects simulated concurrently. Beyond this point, the physics system would begin to drop physics frames, resulting in wild and unrealistic behaviour from the softbodies.\nRendering It was found that when more than 32 softbodies were rendered concurrently, the GPU memory usage of the fully rendered dynamic mesh method began to be higher than that of the simplified wireframe rendering method. Additionally, beyond this point, the frame render time began to be much higher using the dynamic mesh rendering, than the wireframe rendering.\nHowever, these values were still fairly low, with the most GPU memory used being 2343 MB, only about 200 MB more than the amount used rendering a scene with no softbodies, and the highest frame render time recorded reaching 13ms, still below the 16.666ms required to reach 60 frames per second.\nIn the tests carried out, the physics simulation would consistently fail before the rendering became an issue in any way, as the number of objects increased. This is likely to be the case regardless of the meshes used for the softbodies, as the same mesh is used to generate both the graphical and physical representations of the softbody objects.\nFuture Work With the current rendering method, a new mesh is uploaded to the GPU each frame, for each soft body, and is not optimal. Instead, a vertex shader could be written and used which could take the new vertex positions as uniform variables, and calculate the normal vectors in parallel on the GPU.\nCurrently, only the point masses that form the soft body provide collision detection and resolution for the softbodies. This is sufficient for collisions against large, flat geometry, but wouldn\u0026rsquo;t function when colliding with rough terrain which would be able to enter the gaps between points. In order to improve the collision detection, more point masses could be added to each face, or alternately, collision detection could be added for each triangular plane on the soft body. The latter method would likely be more efficient, but would be unable to deform around smaller obstacles, like the former method could.\nUsing polygonal meshes, designed to represent objects graphically, as the structure of a physics object introduces some issues. Notably, convex shapes are not stable using the current method of constructing a network of masses at each vertex location, and springs to connect them. It would be useful to explore algorithms that could determine the stability of a given mesh when converted to a spring-mass soft body, and locate effective pairs of points to add spring connections to, in order to stabilise the object.\n","permalink":"https://charliehart.dev/3d/softbody-physics-diss-en/","summary":"This project was my postgraduate dissertation project, titled \u0026lsquo;Realtime Soft Body Simulation using a Spring-Mass approach\u0026rsquo;. This post can be considered a condensed summary of the dissertation document, and more detailed information can be found at the following link:\nThe Dissertation document can be found here\nSoft bodies are physically simulated objects capable of deformation - changing shape in response to forces experienced. Most physical objects in computer simulations are rigid bodies, which do not experience deformation, but soft body physics systems are required in order to simulate complex structures in a physically accurate way, such as clothing.","title":"Realtime Softbody Physics - Postgraduate Dissertation Project"},{"content":"This project was created for my University team project, and is a 3D platformer game, in which the player has to reach the end of an obstacle course and achieve the fastest time they can. We created the game as a team of a few students working as a \u0026lsquo;Mini-Studio\u0026rsquo; at Newcastle University.\nOur project was created using our own engine in C++, and was based on the \u0026lsquo;Goat Heist\u0026rsquo; game I created as a previous coursework project; We expanded the codebase significantly, to add a wider range of features to a new game in the engine.\nVideo Screenshots Level 1 - Gate Gallop\nLevel 3 - Obstacle Course\nTeam Organisation and Communication Throughout the project, we used many tools to assist in communication and organisation:\nGit, for Version Control and developing several features in parallel, making use of branches.\nJenkins, for automated building of our project and reporting of issues when a push was made to Git.\nMicrosoft Teams, for team communication, and the Teams add-on \u0026ldquo;Tasks by Planner\u0026rdquo;, for creating kanban boards to track tasks.\nMini Code Reviews In order for a new feature to be merged into the main branch of our repository, we performed \u0026lsquo;Mini Code Reviews\u0026rsquo;, where the member merging the branch would sit down with another member of the team and read through their code, explaining what it does, and ensuring it was ready to be merged.\nI also performed these reviews several times upon the request of other team members, when they required assistance to debug their code, and this really sped up the time it took to fix bugs in our program, maximising the time available to work on other features.\nDevelopment In this section, I\u0026rsquo;ll cover the areas of the game\u0026rsquo;s codebase I worked on.\nAxial Constraints I added optional axial constraints to physics objects in the engine, per axis, for both linear motion and angular motion.\nFor example, an object with constrained linear motion on the X,Y and Z axis cannot move linearly (change position) as a result of physics calculations, but can rotate.\nThe constraint state of a physics object is stored as an eight bit value, where the lowest 6 bits represent a true or false constraint in each of the 3 axis of linear and angular motion.\nBefore calculating the new position of an object in the physics tick, a check is performed, and if any axial constraints are applied to the object, the relevant linear or angular velocity component is set to zero.\nUsage Axial Constraints were used for both the player and enemies, to ensure that they were unable to rotate on any axis other than Y, therefore constraints on the X and Z angular motion were applied.\nTrigger Volumes Trigger Volumes are another feature I added to the codebase. Trigger Volumes are physics objects which are not \u0026lsquo;solid\u0026rsquo;, that is, no collision resolution is applied to a collision involving one or more Trigger Volumes. However, they will run one or more functions when an object begins to and finishes colliding with the volume.\nAs creating a Trigger Volume is as simple as setting the m_isTrigger flag on an object to true, a Trigger Volume can be made of any physics object with any existing collider shape already implemented.\nUsages Checkpoints and Respawn Triggers Trigger Volumes were used for both Checkpoints and Respawn Triggers in this game. When a player enters a Checkpoint trigger, the player\u0026rsquo;s current position and orientation are stored.\nWhen the player enters a Respawn trigger, their position and orientation are set to these stored values, and their velocity, both linear and angular, are set to zero.\nThis allowed us to set exactly where we deemed \u0026lsquo;Out of Bounds\u0026rsquo; for the player, and was a much better method than what was used previously, resetting the player\u0026rsquo;s position to a set value when the players y position was below a certain threshold.\nPlayer Detection Boxes \u0026lsquo;Player Detection Boxes\u0026rsquo; are a type of Trigger Volume that tracks the player objects currently inside the volume, in a std::set\u0026lt;PlayerCharacter*\u0026gt;. These are used by the rhino enemies, to determine the closest player to them, within their patrolled area.\n// PlayerDetectorBox.h class PlayerDetectorBox : public TriggerBox { public: void onCollisionBegin(GameObject* t_otherObject) { if (t_otherObject-\u0026gt;GetType() == ObjectType::Player) { m_playersDetected.insert((PlayerCharacter*)t_otherObject); } } void onCollisionEnd(GameObject* t_otherObject) { if (t_otherObject-\u0026gt;GetType() == ObjectType::Player) { m_playersDetected.erase((PlayerCharacter*)t_otherObject); } } std::set\u0026lt;PlayerCharacter*\u0026gt;* getPlayers() { return \u0026amp;m_playersDetected; } protected: std::set\u0026lt;PlayerCharacter*\u0026gt; m_playersDetected; }; Note that the game did not end up having multiplayer functionality, but at the time this feature was added, multiplayer was still a planned feature.\nRhino Enemy The rhino enemies in the game are state machine controlled, and use the following logic:\nIdle state - remain still until a player enters the rhino\u0026rsquo;s player detection volume, then enter Targeting state.\nTargeting state - smoothly orients itself towards the nearest player inside the detection volume, and enters Attacking state a set time after entering the Targeting state.\nAttacking state - force is applied in the direction the rhino is pointing, to make it charge in the targeted direction. The rhino does not change its targeted direction after entering this state, so it charges in a straight line. If the rhino leaves it\u0026rsquo;s player detection volume, for example by charging out of it, the rhino will smoothly return to the volume and revert to the Idle state.\nMap editor/importer tool In order to design levels for the game, a graphical map editor was required. Hard-coding the positions, sizes and orientations of each element in a level would take far too long, and is not an intuitive way to work.\nI designed a Map Exporter tool for the Unity engine, in C#, which would convert a scene designed in Unity\u0026rsquo;s graphical editor, into a .json file, containing information such as :\nObject positions, sizesand orientations\nObject Types (Geometry, Player, Rhino, Checkpoint etc)\nRender Meshes\nCollider types\nPhysics Object inverse masses\nand much more information, where applicable to a given object.\nThe graphical map editor in Unity, showing level 4 of the game:\nI then wrote a corresponding tool in C++, making use of The Rapidjson Library, to read a map file in .json format, and spawn the objects in the game world.\nIt can also load a map file in at a given offset position, so it is possible to add a stage to the game inbetween existing stages, only the offset position would need to be changed, on the line calling the loadMapFromJSON() function.\n// MapImporter.h (Snippet) ... static void loadMapFromJSON(std::string t_fileName, GameWorld\u0026amp; t_world, Vector3 t_offset = Vector3(0, 0, 0)); ... This tool allowed us to spend less time on level design - something not being assessed in this coursework - and more time on implementing other features into our game and engine.\nDebug UI Elements Another team member created a Debug UI in the game using ImGUI, which can be accessed by pressing the I key.\nI added several elements to this UI, displaying information such as:\nFrame rate in fps, and Frame time in ms\nPhysics tick time in ms\nRender tick time in ms\nA representation of the world axes in the viewport\nFuture Work An object tree, where an object can have several child objects that move as the parent moves, would be useful to enable more complex gameplay.\nThe physics system could be optimised, by not checking for collisions between objects pairs, when both are fully constrained.\nIt would be convenient to be able to load a map from a file in any orientation. Currently, it can only be loaded in the orientation it was designed in.\nImplementation of networking and multiplayer to the game. This would require a redesign of several existing features, and may take some time.\n","permalink":"https://charliehart.dev/3d/descending-dudes-en/","summary":"This project was created for my University team project, and is a 3D platformer game, in which the player has to reach the end of an obstacle course and achieve the fastest time they can. We created the game as a team of a few students working as a \u0026lsquo;Mini-Studio\u0026rsquo; at Newcastle University.\nOur project was created using our own engine in C++, and was based on the \u0026lsquo;Goat Heist\u0026rsquo; game I created as a previous coursework project; We expanded the codebase significantly, to add a wider range of features to a new game in the engine.","title":"Descending Dudes - Postgraduate 3D Team Project"},{"content":"My first emulator project is to write a Gameboy emulator, in C++, and is a large project with several stages, so more posts will be made as new sections are added.\nAt the time of writing, I have implemented the Gameboy\u0026rsquo;s CPU, memory bus and instruction set.\nUpdate 01/10/2024: Part 2 of this project can be found here.\nGithub Repository GitHub - CharlieHart0/GameBoyEmu: A GameBoy emulator\n(The project is ongoing, and cannot yet be used as a full emulator)\nCPU The most important part of the CPU to be modelled is the set of 8 bit registers, of which there are 8, A,B,C,D,E,F,H and L.\nThe register F is used as the flag register, and the higher half of this register is used for the carry, half carry, subtraction and zero flag bits respectively, which are used to indicate the result of operations.\nThe register pairs AF, BC, DE and HL can also be used to store a single 16 bit value, instead of two 8 bit values, and the register pair HL is often used to store 16 bit memory addresses.\nAlso in the CPU model are the program counter and stack pointer, each of which are 16 bit memory addresses. The program counter points to the location of the next instruction bit to be excecuted, while the stack pointer points to the top of the stack - the stack in the Gameboy starts at the end of memory and works its way backwards as it grows.\nInstructions In order to emulate the Gameboy\u0026rsquo;s CPU, I had to implement the instruction set, which has about 500 different combinations of instruction and operands. A table of opcodes can be found here\nA table of all 8 bit opcodes.\nIf the byte 0xCB is used as an instruction byte, then a second table of 255 opcodes is used, where the byte following 0xCB is used. These are referred to as the 16-bit prefixed opcodes, and are mostly bit operations, to make a total of around 500 instructions.\nThe instructions include the following, and many others:\nAddition and subtraction\nBitwise AND, OR, XOR and comparison operations\nMoving values between registers\nPushing and Popping the values of 16 bit register pairs to the stack\nControl flow operations such as Jumping based on the value of flags in the flag register\nBit rotations, setting and resetting of bits, and bit swapping.\nMemory Map The Game Boy\u0026rsquo;s memory is treated as a single long array of 65,535 8 bit values, but only a small section of this is the actual working RAM of the device, and most of this \u0026lsquo;memory\u0026rsquo; is instead mapped to many things including but not limited to:\nThe Boot ROM 0x0000 - 0x00FF: ROM which sets up the Game Boy\u0026rsquo;s hardware in order to run a game. The Boot ROM is unloaded when a game starts.\nGame ROM banks 0x0000 - 0x3FFF and 0x4000-0x7FFF: These areas of memory are where data from the game cartridge can be loaded as needed during excecution of the game.\nTile RAM 0x8000 - 0x97FF: Stores tiles of graphics information which can be displayed on the screen. The GB\u0026rsquo;s tiling system does not allow direct control of individual pixels, instead tiles are used to display square groups of pixels at certain locations.\nCartridge RAM 0xA000 - 0xBFFF: Some game cartridges come with extra RAM on board, this area maps to this RAM.\nWorking RAM 0xC000 - 0xDFFF: The area of RAM that a game is allowed to use. The only area in which the memory can be freely read from and written to by a game.\nFuture Work The CPU is implemented, but cannot be tested yet until a Boot ROM can be loaded into memory.\nThe next step is to create a tile inspector, to view the GB\u0026rsquo;s tile memory, and allow the graphics portion of the emulator to be implemented. I plan to use GTK to create this GUI.\nOnce the graphics have been implemented in the emulator, I will be able to run test programs to ensure that the CPU instructions work correctly\nFollowing that, both Audio and Input are required.\nUpdate 01/10/2024: Part 2 of this project can be found here.\n","permalink":"https://charliehart.dev/misc/gameboy-emulator-en/","summary":"My first emulator project is to write a Gameboy emulator, in C++, and is a large project with several stages, so more posts will be made as new sections are added.\nAt the time of writing, I have implemented the Gameboy\u0026rsquo;s CPU, memory bus and instruction set.\nUpdate 01/10/2024: Part 2 of this project can be found here.\nGithub Repository GitHub - CharlieHart0/GameBoyEmu: A GameBoy emulator\n(The project is ongoing, and cannot yet be used as a full emulator)","title":"Creating a Gameboy Emulator - Part 1"},{"content":"Hi! I\u0026rsquo;m Charlie, a game developer and student currently in my fourth year at Newcastle University in the UK, where I am studying Computer Science (Games Engineering) at master\u0026rsquo;s level.\nSince 2018, I have been developing games both in my spare time and as part of my University course, ranging from small experiments and gamejam projects to larger projects, such as my undergraduate dissertation project.\nI have experience in both Unity and Unreal Engine, both in C# and C++, and several of my projects have been created without the use of an engine, in C++. My website also features other projects I\u0026rsquo;ve been working on in my spare time not directly related to game development.\nYou can contact me at charlie@charliehart.dev\n","permalink":"https://charliehart.dev/about/","summary":"Hi! I\u0026rsquo;m Charlie, a game developer and student currently in my fourth year at Newcastle University in the UK, where I am studying Computer Science (Games Engineering) at master\u0026rsquo;s level.\nSince 2018, I have been developing games both in my spare time and as part of my University course, ranging from small experiments and gamejam projects to larger projects, such as my undergraduate dissertation project.\nI have experience in both Unity and Unreal Engine, both in C# and C++, and several of my projects have been created without the use of an engine, in C++.","title":"About me"},{"content":"You can contact me at charlie@charliehart.dev\n","permalink":"https://charliehart.dev/contact/","summary":"You can contact me at charlie@charliehart.dev","title":"Contact"},{"content":"I recently modded my PS Vita, using HENkaku and Ensō, so that I was able to install unsigned software, and begin exploring the Vita homebrew community, and potentially make my own games/programs for the system!\nDisclaimers I do not support pirating games, this project was focused on exploring the Vita system and the homebrew created for it!\nI do not claim responsibility for any consequences if you attempt this with your own device, you do so at your own risk and may void the manufacturer\u0026rsquo;s warranty!\nThis post also does not serve as a comprehensive set of instructions for modding a PSV, please see https://vita.hacks.guide/ for guides to installing custom firmware!\nPrerequisites For the method I chose, a combination of HENkaku and Ensō, the system needs to be using either firmware 3.60 or lower. Other methods are available for systems updated beyond this point, but they are not covered here. My PSV hadn\u0026rsquo;t been used for many years at this point, so it wasn\u0026rsquo;t updated past this point.\nHENkaku and Molecularshell The first step I took was to run HENkaku on the PSV. HENkaku is a Japanese word meaning \u0026ldquo;to change radically, to make something new\u0026rdquo;, which is definitely true, as this process revived the interest I had in what is admittedly a pretty forgotten console by now.\nHENkaku is an exploit chain for the PSV which allows the installation of homebrew applications on the home screen, and is not persistent, meaning that it does not remain installed when rebooting the system. For this reason, Ensō must be installed later in order to retain access to these features once the device is rebooted.\nInstructions In order to install HENkaku, launch the internet browser on the PSV and go to http://henkaku.xyz/. After clicking \u0026lsquo;Install\u0026rsquo;, the PSV will launch the exploit, and if the exploit is successfully completed, a new icon will appear on the home screen, called \u0026lsquo;MolecularShell\u0026rsquo;.\nMolecularShell, and a similar program VitaShell, are effectively file managers, used to view and transfer files on the device. MolecularShell can be used to host an FTP server for file transfers, or to transfer files via USB connection too. Another significant feature is that it allows us to install files such as .vpk,.pkg and many others, to install new unofficial programs created by the community.\nNext, navigate to the normal Settings app on the PSV, and you will see a new \u0026lsquo;HENkaku Settings\u0026rsquo; tab. Here, check \u0026lsquo;Enable Unsafe Homebrew\u0026rsquo;. This is required for the system to allow the custom programs to be installed.\nEnsō Ensō is a sacred symbol in the Zen school of Buddhism, and can be loosely translated as \u0026ldquo;Mutual Circle\u0026rdquo;. This is pretty appropriate, as this is the software which allows the previous modifications to persist through reboots, so that the PSV can be used as normal.\nIt runs an exploit at boot time to set up the HENkaku environment automatically, and is much more convenient than opening the internet browser each time. Additionally, it does not require an internet connection, as HENkaku\u0026rsquo;s manual installation does.\nInstructions First, we have to download both Enso and VitaShell to our PC - only the .vpk files are required here.\nInside either MolecularShell or VitaShell, press SELECT to host an FTP server on the device, and connect with a client such as WINSCP or Filezilla. Alternatively, a connection could be made through a micro USB cable.\nTo install a .vpk file, move it to ux0:data/, and run the .vpk file inside Molecular or Vita Shell.\nOnce these apps are both installed, find Enso on your home screen and run it. Once installation has completed, press X to reboot your device, and the exploit should now remain installed on your device permanently (or at least until you choose to uninstall it, more importantly, it will not dissapear after rebooting now).\nReccomended software and next steps can be found here, and will allow you to things such as connecting to PlayStation Network on a modded console, or provide some nice quality of life improvements to the PSV.\nRipping Games from Cartridges With MolecularShell or VitaShell installed, it is possible to rip games from their retail cartridges and install them on the internal storage, or your memory card, so that they can be played without inserting the card, like a downloaded game.\nWith the game card inserted into the PSV, a new drive will be visible inside VitaShell, gro0. ro means Read-Only, so don\u0026rsquo;t worry about accidentally wiping your only copy of Minecraft: PS Vita Edition off the card :) . On this drive, you will see all the files that are on the game card. You will see a folder with a name something like LLLLDDDDD/, where L is a letter and D is a digit, for example, Minecraft is PCSB00560/.\nHit Triangle, and in the menu that appears, select Copy, and then navigate to ux0:app/, and hit Triangle again and select Paste to copy the game to your internal storage. Once you\u0026rsquo;ve done this, you may need to navigate back to the root of VitaShell, where all the drives are visible, and select \u0026ldquo;Refresh LiveArea\u0026rdquo; in the Triangle menu in order to see the game on your home screen.\nNow, the game should be playable without having the card installed! Bear in mind that if you insert the game card again, the system may ask you which version you want to use, and make sure to choose the right option here, as your save games on the copied version will not be available if you choose to run the game from the card! Though they will remain safe and usable once the card is removed again, and the newly copied version is the only version available to the PSV.\nSD2Vita I\u0026rsquo;ll keep this section brief, but a common problem you\u0026rsquo;ll experience once a few games are installed is that the memory cards sold by Sony are ridiculously expensive compared to microSD cards, and are a proprietary format, so they are not able to be used with your PC unless the Vita is used as an adapter, through VitaShell\u0026rsquo;s USB connectivity functionality.\nA SD2VITA adapter can be bought online, which adapts a microSD card to fit into the game cardridge slot on the top of the device. With this, you can potentially have a Terabyte of storage, at a fraction of the cost of Sony\u0026rsquo;s cards.\nCheck out this guide for more information!\nFuture Work I\u0026rsquo;m exploring the Vita SDK, and plan on creating at least a couple simple programs on the device, potentially a small game, depending on how the process goes!\nI would like to create a program that allows you to use your PSV as a USB game controller with your PC\n","permalink":"https://charliehart.dev/misc/vita-hacking-en/","summary":"I recently modded my PS Vita, using HENkaku and Ensō, so that I was able to install unsigned software, and begin exploring the Vita homebrew community, and potentially make my own games/programs for the system!\nDisclaimers I do not support pirating games, this project was focused on exploring the Vita system and the homebrew created for it!\nI do not claim responsibility for any consequences if you attempt this with your own device, you do so at your own risk and may void the manufacturer\u0026rsquo;s warranty!","title":"Modding the PS Vita"},{"content":"This is part 2 of an ongoing project in C++ to create an emulator of the Nintendo Gameboy. Since the last post, I have added a GUI for debugging, including inspectors for the CPU state, the Gameboy\u0026rsquo;s Memory, a visualization of Graphics Memory, and a ROM loader.\nGithub Repository https://github.com/CharlieHart0/GameBoyEmu (The project is ongoing, and is not yet fully usable)\nSDL and ImGui ImGui, a C++ GUI library, was used in combination with SDL2 and OpenGL3 to add a GUI to the program, through which different parts of the emulator could be debugged. Eventually, SDL will be used to manage user input, audio, and rendering the gameboy\u0026rsquo;s screen to the user\u0026rsquo;s display.\nGUI windows Each of the following sections has its own window in the application:\nCPU Inspector The CPU Inspector displays to the user the current state of all of the CPU\u0026rsquo;s registers, the program counter, the stack pointer, and the last called instruction. While in debug mode, the inspector also shows the number of instructions completed, and the average duration of instructions, in nanoseconds, which is used to ensure that the performance of the CPU can keep up with the clock speed of the Gameboy\u0026rsquo;s CPU.\nIn addition to this, it also lets the user apply a speed modifier to the CPU loop, which allows the user to see what the CPU is doing at an appropriate timescale, as the step by step state of the ~4MHz CPU would be impossible for the user to view in realtime. The user can also click \u0026ldquo;Tick CPU\u0026rdquo; to step the CPU through instructions one at a time.\nMemory Inspector The Memory Inspector, inspired by programs such as HxD, displays the contents of the Gameboy\u0026rsquo;s 63556 byte memory, showing 256 bytes at a time. Addresses are highlighted with different colours if they are significant, such as:\nThe current location of the Program Counter The current location of the Stack Pointer Addresses within the stack Bookmarked addresses (Significant hardware registers, user defined bookmarks etc.) The results of Find/Replace actions On the right hand side of the window, the value is shown in a variety of formats, including Hex, Decimal, Binary, ASCII, and as both an 8 bit, and prefixed Instruction byte. Buttons can be used to seek left and right around the neighbouring bytes, as well as to jump to the beginning or the end of the memory.\nBookmarked Addresses Within the memory inspector, there are almost one hundred addresses bookmarked by default, for example the audio registers, LCD scrolling position and status registers, and many more. These are all values which are important to check during debugging, and would otherwise be difficult to locate. Through a menu, the user can jump to any of these bookmarked addresses, or add their own bookmarks. Bookmarked Addresses are highlighted in the memory inspector.\nFind/Replace The Find/Replace menu can be used to locate values within a selected area of memory, or the entire memory. The results will be highlighted in the memory inspector with a yellow background, so the user can easily find them. If memory editing has been enabled, the user can also replace the found values with another value.\nROM Loader The ROM loader is used to load a ROM file (this could be a homebrew game, or debug ROM for example) into the Gameboy\u0026rsquo;s memory, as well as extracting and displaying the metadata found on the ROM header.\nOne of the most important pieces of information in the ROM header is the cart type, which defines the hardware found on a physical cartridge, including extra RAM, ROM banks, rumble packs and more. Many of these hardware features need to be implemented and used on top of the default hardware found in the Gameboy. ROM banks, for example, are used on many games, and the Gameboy must be able to access these banks to load them into the memory during runtime.\nNote that the ROM is not currently loaded into the Gameboy\u0026rsquo;s memory when using the ROM loader, as the boot ROM must finish first, which requires further development of the PPU. Therefore, its only use at the moment is to display header information.\nExample: This is what the header of Pokemon Red might look like.\nGraphics Inspector The Graphics Inspector displays the contents of the VRAM (Tile Data) in real time. This consists of three blocks of 128 8x8 pixel tiles, which are used to construct the scenes in a Gameboy game. There are only four different colours to choose from in each tile, and each 8x8 tile occupies 16 bytes in memory.\nBlock 0 of the VRAM. This image shows random data in the VRAM, as roms are not yet loadable.\nPPU The PPU (Pixel Processing Unit) is responsible for rendering and displaying rows of pixels to the LCD display of the Gameboy, in a similar way to how an old CRT screen would work. Horizontal lines are drawn, with each line consisting of three modes, OAM scan, Drawing, and Horizontal blank. When the frame has been fully drawn, and the current scan line is more than or equal to 144, the VBlank period starts, where most of the changes to the VRAM by the CPU will occur.\nCredit: Rendering - Pan Docs\nCurrently, the PPU follows the expected timing of a Gameboy PPU as seen above (1 dot = 238.45 nanoseconds), although nothing is actually done, and no display exists yet, only the LY register (current scan line) is incremented.\nFuture Work The next steps for this project include:\nFurther develop the PPU to write the correct values to all relevant hardware registers Ensure mutual exclusion locks are applied correctly to the PPU thread when accessing shared resources - This is already implemented for the CPU and UI threads Add memory mapping support for ROMs with a memory mapper Run simple one-bank ROMs such as tetris successfully, though without a display. ","permalink":"https://charliehart.dev/misc/gameboy-emulator-part2-en/","summary":"This is part 2 of an ongoing project in C++ to create an emulator of the Nintendo Gameboy. Since the last post, I have added a GUI for debugging, including inspectors for the CPU state, the Gameboy\u0026rsquo;s Memory, a visualization of Graphics Memory, and a ROM loader.\nGithub Repository https://github.com/CharlieHart0/GameBoyEmu (The project is ongoing, and is not yet fully usable)\nSDL and ImGui ImGui, a C++ GUI library, was used in combination with SDL2 and OpenGL3 to add a GUI to the program, through which different parts of the emulator could be debugged.","title":"Creating a Gameboy Emulator - Part 2 - Ongoing"},{"content":"The Goat Heist game was my coursework for the module \u0026lsquo;Advanced Game Technologies\u0026rsquo;, where we were tasked with creating a simple game in C++. We were given a codebase which handled the graphics portion of the game, but needed to add a physics system, some physics related game mechanics, state based AI and pathfinding.\nThe required features for the coursework included:\nCreate a game in which the player must attempt to steal a guarded item from a building inside a voxelised world.\nThere should be items in the world which can be picked up by the player to aid them.\nPoints should be awarded for progressing towards the goal.\nThe player should be controlled by the keyboard via forces or impulses\nThe game should feature a simple state based menu system\nCollision detection and resolution should be used to create obstacles for the player\nWhen the player steals the heist item, they must make their way back to the start while all enemies now pathfind towards the player at all times.\nAI characters should patrol the level and pursue the player when a line of slight is made, using raycasting and a pathfinding algorithm.\nDevelopment Physics The base game I was given to build from did not have much of a physics system at all, and over the course of development, many features were added, such as Raycasting, Linear and Angular Motion, Collision Detection and Response.\nRaycasting was used by the enemy actors to determine whether the player was considered \u0026lsquo;Visible\u0026rsquo; to an enemy, and had a line of sight to it. This would inform the AI\u0026rsquo;s behaviour, covered later.\nThe linear and angular motion implemented several functions to perform operations such as integrating linear and angular acceleration and velocity for a given set of forces for each time step, allowing forces to be applied to objects, and for the objects to then move in a realistic manner as a result of these forces.\nCollision detection between spheres and Axis Aligned bounding boxes was implemented, with collisions returning collision information such as pointers to both objects involved in the collision and the location and orientation of the contact point or area between the two objects, and by what penetration distance the objects have intersected.\nThe impulse method was used for collision resolution, where the linear and angular velocities of the two PhysicsObjects were changed without integrating the acceleration first. This uses a coefficient of restitution to determine how much velocity is affected by the loss of kinetic energy due to deformation or conversion to thermal energy.\nAI State Machines The enemy actors in the game make use of AI and pathfinding features, and the enemies operate using a simple state machine, with three states: Patrol, Chase Player and Target Player. Transitions between these states occur when a condition is met, and the state machine is in the correct state to be able to transition to another.\nPatrol - The enemy will choose a random reachable location inside the maze, and move towards it.\nChase Player - When the player is in sight of the enemy (a raycast to the player is not blocked by any collider), the enemy moves in a straight line towards the player.\nTarget Player - When the player picks up the heist goal item and starts heading back to the starting location, all enemies will pathfind towards the player, regardless of if the player is visible, as the alarms have been triggered.\nA state machine is also used for the simple menu system in the game, and to implement different behaviour depending on the current game state - pregame, in progress or game over.\nPathfinding The A Star algorithm is used with a grid based navigation mesh for the enemies\u0026rsquo; pathfinding. The game level is loaded using the methods described below, and the tiles considered solid - doors and walls - are areas that the enemies are unable to walk through, whereas all other tiles are not solid.\nIn game, Debug lines are drawn on screen showing the current path taken by each enemy. Green lines show the full path that will be taken by the enemy, and a light blue line shows the forces being applied to the enemy to move it towards the next waypoint in the path.\nNetworking Some basic networking features were added into the codebase as part of the module work, though they did not ultimately make their way into the final game due to time constraints.\nPNG level loader As part of this project, I had to change the design of the game level many times to accomodate and show the new features that were added. When the walls of the level are made of cubes, the positions of which must be manually entered line by line in code, this made iterating on the level design very slow. In order to solve this issue, without spending too much time to do so - as no marks were given for level design - I wrote a couple of functions to load a level using a PNG image, where different coloured pixels represented different objects/entities to be placed on a grid layout.\nThe stb_image image loader was used to load a PNG file, and then, for each pixel in the image, a corresponding world space position was calculated, according to the given scale value, and then one of many objects was placed at the location, such as doors, keys, enemies, or walls.\nuint8_t* rgb_image = stbi_load(\u0026#34;../Assets/map3.png\u0026#34;, \u0026amp;width, \u0026amp;height, \u0026amp;bpp, 3); for (int h = 0; h \u0026lt; height; h++) { for (int w = 0; w \u0026lt; width; w++) { int locationInt = (w+(h*width)) * 3; Vector3 col = Vector3(rgb_image[locationInt], rgb_image[locationInt + 1], rgb_image[locationInt + 2]); if (col == Vector3(0, 0, 0)) { continue; } Vector3 location = mapOrigin + Vector3(w * 2.0f * cubeHalfDim, 0, h * 2.0f * cubeHalfDim); // a switch statement would be nice here but it didnt seem to want to work with vector3s if (col == Vector3(255, 255, 255)) { AddCubeToWorld(location, cubeDimensions, 0.0f); continue; } if (col == Vector3(255, 0, 0)) { AddDoorCube(location,cubeDimensions); continue; } if (col == Vector3(0, 255, 255)) { AddStartingPlate(location); for (PlayerCharacter* p : players) { p-\u0026gt;GetTransform().SetPosition(location); p-\u0026gt;SetInitPosition(location); } continue; } if (col == Vector3(255, 255, 0)) { AddBonusToWorld(location,GameObject::ObjectType::PickupKey); continue; } if (col == Vector3(255, 0, 255)) { AddBonusToWorld(location, GameObject::ObjectType::PickupGoal); continue; } if (col == Vector3(0, 0, 255)) { AddBonusToWorld(location, GameObject::ObjectType::PickupInvisibility); continue; } if (col == Vector3(191, 191, 191)) { GameObject* cube = AddCubeToWorld(location, cubeDimensions, 2.0f); cube-\u0026gt;GetRenderObject()-\u0026gt;SetColour(Vector4(0.3f, 0.3f, 0.3f,1)); continue; } if (col == Vector3(255, 100, 0)) { AddEnemyToWorld(location); continue; } } } stbi_image_free(rgb_image); An example of the PNG from which the level would be loaded. Upscaled by 400% in order to display properly on this website.\nFuture Work Networking and a multiplayer component to the game, with the player able to host a game and connect to other players by entering their IP address\nFriction between physics objects should be implemented, so that the actors in the game do not slide around on the floor when moving. This would also give the player greater control over the player character.\nComplex shaped collision volumes, such as capsules or oriented bounding volumes.\nBehaviour trees could be added to the enemy AI in order to give them more complex behaviours and gameplay interaction.\nThe addition of collision layers and trigger volumes would allow for a wider variety of gameplay features, and would improve some present features, such as powerups which the player does not collide with, making them lose all momentum.\nPhysics objects could each have a unique coefficient of restitution, with each collision pair using a calculated value for its CoR, as an average of the two colliding objects\u0026rsquo; CORs.\n","permalink":"https://charliehart.dev/3d/goat-game-en/","summary":"The Goat Heist game was my coursework for the module \u0026lsquo;Advanced Game Technologies\u0026rsquo;, where we were tasked with creating a simple game in C++. We were given a codebase which handled the graphics portion of the game, but needed to add a physics system, some physics related game mechanics, state based AI and pathfinding.\nThe required features for the coursework included:\nCreate a game in which the player must attempt to steal a guarded item from a building inside a voxelised world.","title":"Goat Heist - 3D Postgraduate Game"},{"content":"\u0026lsquo;Paid in Blood\u0026rsquo; was my entry to Trijam #226, a game jam with the twist of being given only three hours to create your game! This does not include planning, compiling or uploading your game, only time spent actively creating the game.\nThe theme for the jam was \u0026lsquo;You gain a little, you lose a little\u0026rsquo;. The idea I settled on for the game was a small roguelite, where the players health is used as a currency to unlock upgrades.\nPlay Game Paid In Blood on Itch.io\nRequired Device: Any device with a mouse and keyboard\nGame Mechanics After clearing a room, the player is given the option to open a chest containing a random permanent power up, at the cost of some health. These upgrades include attack damage, attack speed, fire rate, number of projectiles per shot, and more.\nClearing a room of enemies without taking damage restores a portion of the player\u0026rsquo;s health, rewarding players who are skilled with the opportunity to spend their health points on more upgrades.\nDevelopment Development of this game was of course done over a very short time frame, even moreso than a typical game jam, but heavy use of third party art assets was essential to allow me to finish the game on time.\nThe layout of the map is randomised every time, though each individual room is of course very similar, as the time constraints did not allow too much variation there.\nThe rooms in the level are always connected using a grid like layout, with rooms either being above, below, to the left or right of each other. For each possible configuration of doors in a room, between one and four doors in each position, prefabricated rooms were designed, which would be used to construct a system of interconnected paths around the map.\nThe algorithm used to generate the map works as follows:\nPlace a random room to start\nKeep track of all rooms containing doors without a room to connect to\nGenerate a random compatible room connected to a random available door\nPrioritise generating rooms with more than one door, until the target number of rooms has been reached\nAdd single door rooms to cap off any remaining incomplete paths\nGamejam Results There were 35 entries submitted to the jam, and Paid in Blood was ranked third by user ratings! However, the games in first and second place were not eligible to win, as their creators had gone over the time limit - something which is allowed, but makes you ineligible for first place. Therefore, Paid in Blood was given first place!\nFuture Work Ideas for future work to develop the game further include:\nMore variation in room design, with different layouts and enemy spawns\nA wider variety of possible upgrades such as added projectile effects (ignite enemies, overpenetrate targets etc)\nRare, higher cost chests, with a better chance of giving the player the more powerful upgrades like multi shot\nPotential bad outcomes from opening chests, to add a further element of risk on top of losing health.\nSomething to happen after all rooms are cleared, such as a boss fight.\n","permalink":"https://charliehart.dev/2d/trijam-paid-in-blood-en/","summary":"\u0026lsquo;Paid in Blood\u0026rsquo; was my entry to Trijam #226, a game jam with the twist of being given only three hours to create your game! This does not include planning, compiling or uploading your game, only time spent actively creating the game.\nThe theme for the jam was \u0026lsquo;You gain a little, you lose a little\u0026rsquo;. The idea I settled on for the game was a small roguelite, where the players health is used as a currency to unlock upgrades.","title":"Trijam #226 - Paid in Blood"},{"content":"My undergraduate dissertation project was to create and optimise a voxel based rendering and world generation system. Inspiration for this project was clearly drawn from Minecraft, one of the most popular games of all time, but also from games such as Astroneer - which uses a voxel system at the core of its player destructible world.\nI used Unity for this project, and created a voxel rendering system which was able to generate a set of triangular meshes, with the correct textures applied, to represent an inputted three dimensional array of blocks, which had been generated using smooth noise functions.\nOptimisations were then added to the project, and their impacts were evaluated. It was found that using object pooling for face meshes increased terrain load speeds by an average of 30.7%, and that \u0026lsquo;internal face culling\u0026rsquo; - that is, generating meshes only for block faces deemed to be exposed to the \u0026lsquo;air\u0026rsquo; in the game world - increased frame rates substantially, by over 1,700%, and allowed significantly larger voxel worlds to be rendered.\nPictured: A screenshot of a 112x48x112 voxel world, using the world generation system to create both hills and caves.\nDissertation Dissertation PDF document\nThe dissertation document goes into significantly more detail about this project, many details are omitted in this post to keep it an appropriate length.\nTry It! Dissertation Github Repository - Contains the excecutable project, recorded test data, and the Unity project files, including all written code.\nRequired Device: Windows PC\nRecommended: At least 8GB of RAM, and a dedicated GPU with at least 2GB of VRAM.\nDevelopment Voxel Rendering Each voxel - wether empty or a solid block - has a corresponding Unity gameobject in the respective voxel position within the world, and when a chunk\u0026rsquo;s RenderChunk() function is called, it calls functions within each voxel object to generate the face meshes required to render the scene.\nThen, the correct block material is applied, with each block\u0026rsquo;s material containing 6 textures to be applied, one for each direction on the world\u0026rsquo;s 3D axis, both positive and negative. These textures are stored on a single image, and loaded into memory together, in the same way a sprite atlas may be used for 2D graphics.\nWorld Generation Terrain is generated in a fixed radius around the camera, in a square shape. As the camera moves on either the X or Z axis, more chunks of terrain are generated, and the chunks which are now outside the specified render distance are removed.\nThe world generation algorithm uses a seed to generate worlds, so that the same world could be used when evaluating the effectiveness of optimisations. For each chunk, a set of nested Lists are used to store block information, one for each axis.\nI realise that this is far from optimal, as reading and writing to lists is much slower than using an array, and there will be a significant amount of repeated data here, for example the approximately 50% of the game world consisting of stone blocks. It may be worth investigating ways to optimise this, as terrain generation was significantly slower than I\u0026rsquo;d like it to be.\nAlgorithm Each voxel\u0026rsquo;s position is used as an input to the evaluateBlock() function, which returns the ID of the block which has been generated at that position. This function completes the following steps:\nIf the Y position is 0, a block of lava is generated, so that any generated caves are guaranteed to have solid blocks at the bottom, and are not open to the void.\nThe height of the hills at this position on the X and Z axis is calculated. Perlin noise is sampled here, and is used to interpolate between the given minimum and maximum hill heights in the world config. A Unity AnimationCurve is used to modify the gradient of hills visually inside the Unity editor.\nCaves are generated. Three dimensional Perlin noise is processed by comparing the square of a sampled value to a threshold value, in order to turn the float samples into boolean values. The samples which evaluate to true here are then set to air blocks, carving holes into the game world.\nFuture Work Areas of future work include:\nVariations of block shapes, such as half blocks, ramps, window panes etc.\nVariations of block shading, such as semi transparent blocks like glass, leaves, windows, or water blocks which could add post processing effects to the screen\nA voxel lighting system could be added, such that some blocks could emit light, with the light attenuating over a distance.\nA system to save and import world configurations, so that custom worlds could be displayed, for example a voxel model instead of a naturally generated world.\nAsynchronous terrain generation could be implemented, or the terrain generation could be further optimised, so that the generation of terrain does not cause the game to freeze.\n","permalink":"https://charliehart.dev/3d/voxel-world-diss-en/","summary":"My undergraduate dissertation project was to create and optimise a voxel based rendering and world generation system. Inspiration for this project was clearly drawn from Minecraft, one of the most popular games of all time, but also from games such as Astroneer - which uses a voxel system at the core of its player destructible world.\nI used Unity for this project, and created a voxel rendering system which was able to generate a set of triangular meshes, with the correct textures applied, to represent an inputted three dimensional array of blocks, which had been generated using smooth noise functions.","title":"Voxel Rendering and World Generation System - C#"},{"content":" The Language Game is a multiple choice quiz game made in Unity, inspired partly by the BBC quiz show \u0026ldquo;Richard Osman\u0026rsquo;s House of Games\u0026rdquo;. In the language round of the show, contestants are presented with a multiple choice question, with both the question and all four answers shown in a random foreign language.\nExpanding upon this concept, my game allows the player to also correctly guess the language in which the question is being asked, in order to gain bonus points.\nAs someone with a hobby in linguistics and language learning, I enjoy learning vocabulary and recognising patterns in foreign languages, and so there are 17 different languages available in the game, so that everybody is able to play with a set of languages they are unfamiliar with.\nDownload Google Play Store Page\nRequired Device: Android device running Android 5.1 or higher\nDevelopment Unity Graphs Translation As the game features 17 different playable languages, I had to look elsewhere for translations, for the questions, answers, and localisation in the game.\nI wrote a python script to search through a JSON file containing everything to be translated in English, and use Google\u0026rsquo;s Translate API to retrieve translations for each element.\nQuestions had to be carefully worded, as to remove as much ambiguity as possible, as many phrases do not translate directly into other languages.\nWhere possible, I had friends check the translations in their languages for errors, though some are likely to remain.\nGoogle Play Store In-App Purchases Although this game is free to play, I included an optional one time purchasable \u0026ldquo;Premium Version\u0026rdquo; upgrade for about GBP £2.00, which would disable adverts in game (shown once per 5 or so games), and provide a further 150 or so questions to the player, with more to be added every so often, for free to users who have bought the upgrade.\nI purposefully made the upgrade optional, and opting to play the game for free does not worsen the player experience, and is intended for the few players who really enjoy the game and want more questions, after having played the base game enough to need more questions.\nPublishing This was my first game made for Android, and so I had to go through the developer registration process for the Google Play Store in order to publish the game.\nI also had to create pictures and icons for the game\u0026rsquo;s Play Store page, something I had not done before. I used Canva, as it came with a handful of presets I could use to make a store listing that looked pretty good!\nFuture Work Unity Localisation system For all the menus and UI in the game, I used my own localisation system, reading the name of text objects in the scene, and reading from the language\u0026rsquo;s JSON file to find the string(s) needed. While this does work, it is pretty limited, and cannot replace select substrings with their localised versions. In the future, I\u0026rsquo;d like to explore Unity\u0026rsquo;s localisation system, to see what it offers.\n","permalink":"https://charliehart.dev/2d/language-game-en/","summary":"The Language Game is a multiple choice quiz game made in Unity, inspired partly by the BBC quiz show \u0026ldquo;Richard Osman\u0026rsquo;s House of Games\u0026rdquo;. In the language round of the show, contestants are presented with a multiple choice question, with both the question and all four answers shown in a random foreign language.\nExpanding upon this concept, my game allows the player to also correctly guess the language in which the question is being asked, in order to gain bonus points.","title":"The Language Game"},{"content":"Double-Barrelled Doppelgänger (DBD) was my entry to Mini Jam 117, a 72 hour gamejam that occurs every two weeks on Itch.io. The theme was \u0026lsquo;Ghosts\u0026rsquo;, as the jam took place in October 2022, near halloween.\nThe additional limitation for the jam\u0026rsquo;s entries was \u0026lsquo;Shotgun as a Mechanic\u0026rsquo;, and so DBD features a noisemaker toy shotgun as one of it\u0026rsquo;s core mechanics.\nPlay Game Double-Barreled Doppelgänger on Itch.io\nRequired Device: Windows PC\nGame Mechanics In DBD, you play as a ghost in a haunted mansion. You must escape from a team of ghostbusters who are trying to kill you, and who run towards the player to suck them into their vacuum packs.\nAs the ghost, you have no weapons or tools besides a single toy shotgun, which is able to make loud noises to scare the ghostbusters away, but will not kill them. You also have the ability to turn invisible for a short period of time.\nThe player has to both lure and scare away the ghostbusters, in order to defeat them using environmental hazards such as spikes.\nDevelopment In DBD, there are hidden trigger volumes which cause events to occur, such as torches lighting up to show the player hints as they progress through the levels. In order for this to work, I used UnityActions, a form of delegation in the Unity game engine. Each trigger zone can be assigned a UnityAction to call when the player enters the zone, and this UnityAction can in turn call several functions. This was essential in order to create trigger zones with varying behaviour in the short time frame I had to develop the game.\nRealtime lighting was used in the 2D scenes of the game, so that the player character\u0026rsquo;s torch could be used to explore the levels, and fit the halloween theme. This presented a few challenges, such as ambient lighting. The ambient lighting in the game was originally much brighter, but had to be darkened so that the other light sources in the game cast strong shadows, as this was one of the concepts that I really wanted in the game.\nSo that the player was still visible, a very weak point light was attached to the player, as the cone of light from the torch does not include the player\u0026rsquo;s position.\nGamejam Results 192 entries were submitted to Mini Jam 117, and DBD came in fourth place! Though I had experience working on personal projects before, this was my first time competing in a gamejam, and I was very happy to recieve many positive and constructive reviews from other contestants on Itch.io\n","permalink":"https://charliehart.dev/2d/doppelganger-en/","summary":"Double-Barrelled Doppelgänger (DBD) was my entry to Mini Jam 117, a 72 hour gamejam that occurs every two weeks on Itch.io. The theme was \u0026lsquo;Ghosts\u0026rsquo;, as the jam took place in October 2022, near halloween.\nThe additional limitation for the jam\u0026rsquo;s entries was \u0026lsquo;Shotgun as a Mechanic\u0026rsquo;, and so DBD features a noisemaker toy shotgun as one of it\u0026rsquo;s core mechanics.\nPlay Game Double-Barreled Doppelgänger on Itch.io\nRequired Device: Windows PC","title":"Mini Jam 117- Double-Barrelled Doppelgänger"}]