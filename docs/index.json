[{"content":"Hi! I\u0026rsquo;m Charlie, a game developer and student currently in my fourth year at Newcastle University in the UK, where I am studying Computer Science (Games Engineering) at master\u0026rsquo;s level.\nSince 2018, I have been developing games both in my spare time and as part of my University course, ranging from small experiments and gamejam projects to larger projects, such as my undergraduate dissertation project.\nI have experience in both Unity and Unreal Engine, both in C# and C++, and several of my projects have been created without the use of an engine, in C++. My website also features other projects I\u0026rsquo;ve been working on in my spare time not directly related to game development.\nYou can contact me at charlie@charliehart.dev\n","permalink":"https://charliehart.dev/about/","summary":"Hi! I\u0026rsquo;m Charlie, a game developer and student currently in my fourth year at Newcastle University in the UK, where I am studying Computer Science (Games Engineering) at master\u0026rsquo;s level.\nSince 2018, I have been developing games both in my spare time and as part of my University course, ranging from small experiments and gamejam projects to larger projects, such as my undergraduate dissertation project.\nI have experience in both Unity and Unreal Engine, both in C# and C++, and several of my projects have been created without the use of an engine, in C++.","title":"About me"},{"content":"You can contact me at charlie@charliehart.dev\n","permalink":"https://charliehart.dev/contact/","summary":"You can contact me at charlie@charliehart.dev","title":"Contact"},{"content":"I recently modded my PS Vita, using HENkaku and Ensō, so that I was able to install unsigned software, and begin exploring the Vita homebrew community, and potentially make my own games/programs for the system!\nDisclaimers I do not support pirating games, this project was focused on exploring the Vita system and the homebrew created for it!\nI do not claim responsibility for any consequences if you attempt this with your own device, you do so at your own risk and may void the manufacturer\u0026rsquo;s warranty!\nThis post also does not serve as a comprehensive set of instructions for modding a PSV, please see https://vita.hacks.guide/ for guides to installing custom firmware!\nPrerequisites For the method I chose, a combination of HENkaku and Ensō, the system needs to be using either firmware 3.60 or lower. Other methods are available for systems updated beyond this point, but they are not covered here. My PSV hadn\u0026rsquo;t been used for many years at this point, so it wasn\u0026rsquo;t updated past this point.\nHENkaku and Molecularshell The first step I took was to run HENkaku on the PSV. HENkaku is a Japanese word meaning \u0026ldquo;to change radically, to make something new\u0026rdquo;, which is definitely true, as this process revived the interest I had in what is admittedly a pretty forgotten console by now.\nHENkaku is an exploit chain for the PSV which allows the installation of homebrew applications on the home screen, and is not persistent, meaning that it does not remain installed when rebooting the system. For this reason, Ensō must be installed later in order to retain access to these features once the device is rebooted.\nInstructions In order to install HENkaku, launch the internet browser on the PSV and go to http://henkaku.xyz/. After clicking \u0026lsquo;Install\u0026rsquo;, the PSV will launch the exploit, and if the exploit is successfully completed, a new icon will appear on the home screen, called \u0026lsquo;MolecularShell\u0026rsquo;.\nMolecularShell, and a similar program VitaShell, are effectively file managers, used to view and transfer files on the device. MolecularShell can be used to host an FTP server for file transfers, or to transfer files via USB connection too. Another significant feature is that it allows us to install files such as .vpk,.pkg and many others, to install new unofficial programs created by the community.\nNext, navigate to the normal Settings app on the PSV, and you will see a new \u0026lsquo;HENkaku Settings\u0026rsquo; tab. Here, check \u0026lsquo;Enable Unsafe Homebrew\u0026rsquo;. This is required for the system to allow the custom programs to be installed.\nEnsō Ensō is a sacred symbol in the Zen school of Buddhism, and can be loosely translated as \u0026ldquo;Mutual Circle\u0026rdquo;. This is pretty appropriate, as this is the software which allows the previous modifications to persist through reboots, so that the PSV can be used as normal.\nIt runs an exploit at boot time to set up the HENkaku environment automatically, and is much more convenient than opening the internet browser each time. Additionally, it does not require an internet connection, as HENkaku\u0026rsquo;s manual installation does.\nInstructions First, we have to download both Enso and VitaShell to our PC - only the .vpk files are required here.\nInside either MolecularShell or VitaShell, press SELECT to host an FTP server on the device, and connect with a client such as WINSCP or Filezilla. Alternatively, a connection could be made through a micro USB cable.\nTo install a .vpk file, move it to ux0:data/, and run the .vpk file inside Molecular or Vita Shell.\nOnce these apps are both installed, find Enso on your home screen and run it. Once installation has completed, press X to reboot your device, and the exploit should now remain installed on your device permanently (or at least until you choose to uninstall it, more importantly, it will not dissapear after rebooting now).\nReccomended software and next steps can be found here, and will allow you to things such as connecting to PlayStation Network on a modded console, or provide some nice quality of life improvements to the PSV.\nRipping Games from Cartridges With MolecularShell or VitaShell installed, it is possible to rip games from their retail cartridges and install them on the internal storage, or your memory card, so that they can be played without inserting the card, like a downloaded game.\nWith the game card inserted into the PSV, a new drive will be visible inside VitaShell, gro0. ro means Read-Only, so don\u0026rsquo;t worry about accidentally wiping your only copy of Minecraft: PS Vita Edition off the card :) . On this drive, you will see all the files that are on the game card. You will see a folder with a name something like LLLLDDDDD/, where L is a letter and D is a digit, for example, Minecraft is PCSB00560/.\nHit Triangle, and in the menu that appears, select Copy, and then navigate to ux0:app/, and hit Triangle again and select Paste to copy the game to your internal storage. Once you\u0026rsquo;ve done this, you may need to navigate back to the root of VitaShell, where all the drives are visible, and select \u0026ldquo;Refresh LiveArea\u0026rdquo; in the Triangle menu in order to see the game on your home screen.\nNow, the game should be playable without having the card installed! Bear in mind that if you insert the game card again, the system may ask you which version you want to use, and make sure to choose the right option here, as your save games on the copied version will not be available if you choose to run the game from the card! Though they will remain safe and usable once the card is removed again, and the newly copied version is the only version available to the PSV.\nSD2Vita I\u0026rsquo;ll keep this section brief, but a common problem you\u0026rsquo;ll experience once a few games are installed is that the memory cards sold by Sony are ridiculously expensive compared to microSD cards, and are a proprietary format, so they are not able to be used with your PC unless the Vita is used as an adapter, through VitaShell\u0026rsquo;s USB connectivity functionality.\nA SD2VITA adapter can be bought online, which adapts a microSD card to fit into the game cardridge slot on the top of the device. With this, you can potentially have a Terabyte of storage, at a fraction of the cost of Sony\u0026rsquo;s cards.\nCheck out this guide for more information!\nFuture Work I\u0026rsquo;m exploring the Vita SDK, and plan on creating at least a couple simple programs on the device, potentially a small game, depending on how the process goes!\nI would like to create a program that allows you to use your PSV as a USB game controller with your PC\n","permalink":"https://charliehart.dev/misc/vita-hacking-en/","summary":"I recently modded my PS Vita, using HENkaku and Ensō, so that I was able to install unsigned software, and begin exploring the Vita homebrew community, and potentially make my own games/programs for the system!\nDisclaimers I do not support pirating games, this project was focused on exploring the Vita system and the homebrew created for it!\nI do not claim responsibility for any consequences if you attempt this with your own device, you do so at your own risk and may void the manufacturer\u0026rsquo;s warranty!","title":"Modding the PS Vita"},{"content":"The Goat Heist game was my coursework for the module \u0026lsquo;Advanced Game Technologies\u0026rsquo;, where we were tasked with creating a simple game in C++. We were given a codebase which handled the graphics portion of the game, but needed to add a physics system, some physics related game mechanics, state based AI and pathfinding.\nThe required features for the coursework included:\nCreate a game in which the player must attempt to steal a guarded item from a building inside a voxelised world.\nThere should be items in the world which can be picked up by the player to aid them.\nPoints should be awarded for progressing towards the goal.\nThe player should be controlled by the keyboard via forces or impulses\nThe game should feature a simple state based menu system\nCollision detection and resolution should be used to create obstacles for the player\nWhen the player steals the heist item, they must make their way back to the start while all enemies now pathfind towards the player at all times.\nAI characters should patrol the level and pursue the player when a line of slight is made, using raycasting and a pathfinding algorithm.\nDevelopment Physics The base game I was given to build from did not have much of a physics system at all, and over the course of development, many features were added, such as Raycasting, Linear and Angular Motion, Collision Detection and Response.\nRaycasting was used by the enemy actors to determine whether the player was considered \u0026lsquo;Visible\u0026rsquo; to an enemy, and had a line of sight to it. This would inform the AI\u0026rsquo;s behaviour, covered later.\nThe linear and angular motion implemented several functions to perform operations such as integrating linear and angular acceleration and velocity for a given set of forces for each time step, allowing forces to be applied to objects, and for the objects to then move in a realistic manner as a result of these forces.\nCollision detection between spheres and Axis Aligned bounding boxes was implemented, with collisions returning collision information such as pointers to both objects involved in the collision and the location and orientation of the contact point or area between the two objects, and by what penetration distance the objects have intersected.\nThe impulse method was used for collision resolution, where the linear and angular velocities of the two PhysicsObjects were changed without integrating the acceleration first. This uses a coefficient of restitution to determine how much velocity is affected by the loss of kinetic energy due to deformation or conversion to thermal energy.\nAI State Machines The enemy actors in the game make use of AI and pathfinding features, and the enemies operate using a simple state machine, with three states: Patrol, Chase Player and Target Player. Transitions between these states occur when a condition is met, and the state machine is in the correct state to be able to transition to another.\nPatrol - The enemy will choose a random reachable location inside the maze, and move towards it.\nChase Player - When the player is in sight of the enemy (a raycast to the player is not blocked by any collider), the enemy moves in a straight line towards the player.\nTarget Player - When the player picks up the heist goal item and starts heading back to the starting location, all enemies will pathfind towards the player, regardless of if the player is visible, as the alarms have been triggered.\nA state machine is also used for the simple menu system in the game, and to implement different behaviour depending on the current game state - pregame, in progress or game over.\nPathfinding The A Star algorithm is used with a grid based navigation mesh for the enemies\u0026rsquo; pathfinding. The game level is loaded using the methods described below, and the tiles considered solid - doors and walls - are areas that the enemies are unable to walk through, whereas all other tiles are not solid.\nIn game, Debug lines are drawn on screen showing the current path taken by each enemy. Green lines show the full path that will be taken by the enemy, and a light blue line shows the forces being applied to the enemy to move it towards the next waypoint in the path.\nNetworking Some basic networking features were added into the codebase as part of the module work, though they did not ultimately make their way into the final game due to time constraints.\nPNG level loader As part of this project, I had to change the design of the game level many times to accomodate and show the new features that were added. When the walls of the level are made of cubes, the positions of which must be manually entered line by line in code, this made iterating on the level design very slow. In order to solve this issue, without spending too much time to do so - as no marks were given for level design - I wrote a couple of functions to load a level using a PNG image, where different coloured pixels represented different objects/entities to be placed on a grid layout.\nThe stb_image image loader was used to load a PNG file, and then, for each pixel in the image, a corresponding world space position was calculated, according to the given scale value, and then one of many objects was placed at the location, such as doors, keys, enemies, or walls.\nuint8_t* rgb_image = stbi_load(\u0026#34;../Assets/map3.png\u0026#34;, \u0026amp;width, \u0026amp;height, \u0026amp;bpp, 3); for (int h = 0; h \u0026lt; height; h++) { for (int w = 0; w \u0026lt; width; w++) { int locationInt = (w+(h*width)) * 3; Vector3 col = Vector3(rgb_image[locationInt], rgb_image[locationInt + 1], rgb_image[locationInt + 2]); if (col == Vector3(0, 0, 0)) { continue; } Vector3 location = mapOrigin + Vector3(w * 2.0f * cubeHalfDim, 0, h * 2.0f * cubeHalfDim); // a switch statement would be nice here but it didnt seem to want to work with vector3s if (col == Vector3(255, 255, 255)) { AddCubeToWorld(location, cubeDimensions, 0.0f); continue; } if (col == Vector3(255, 0, 0)) { AddDoorCube(location,cubeDimensions); continue; } if (col == Vector3(0, 255, 255)) { AddStartingPlate(location); for (PlayerCharacter* p : players) { p-\u0026gt;GetTransform().SetPosition(location); p-\u0026gt;SetInitPosition(location); } continue; } if (col == Vector3(255, 255, 0)) { AddBonusToWorld(location,GameObject::ObjectType::PickupKey); continue; } if (col == Vector3(255, 0, 255)) { AddBonusToWorld(location, GameObject::ObjectType::PickupGoal); continue; } if (col == Vector3(0, 0, 255)) { AddBonusToWorld(location, GameObject::ObjectType::PickupInvisibility); continue; } if (col == Vector3(191, 191, 191)) { GameObject* cube = AddCubeToWorld(location, cubeDimensions, 2.0f); cube-\u0026gt;GetRenderObject()-\u0026gt;SetColour(Vector4(0.3f, 0.3f, 0.3f,1)); continue; } if (col == Vector3(255, 100, 0)) { AddEnemyToWorld(location); continue; } } } stbi_image_free(rgb_image); An example of the PNG from which the level would be loaded. Upscaled by 400% in order to display properly on this website.\nFuture Work Networking and a multiplayer component to the game, with the player able to host a game and connect to other players by entering their IP address\nFriction between physics objects should be implemented, so that the actors in the game do not slide around on the floor when moving. This would also give the player greater control over the player character.\nComplex shaped collision volumes, such as capsules or oriented bounding volumes.\nBehaviour trees could be added to the enemy AI in order to give them more complex behaviours and gameplay interaction.\nThe addition of collision layers and trigger volumes would allow for a wider variety of gameplay features, and would improve some present features, such as powerups which the player does not collide with, making them lose all momentum.\nPhysics objects could each have a unique coefficient of restitution, with each collision pair using a calculated value for its CoR, as an average of the two colliding objects\u0026rsquo; CORs.\n","permalink":"https://charliehart.dev/3d/goat-game-en/","summary":"The Goat Heist game was my coursework for the module \u0026lsquo;Advanced Game Technologies\u0026rsquo;, where we were tasked with creating a simple game in C++. We were given a codebase which handled the graphics portion of the game, but needed to add a physics system, some physics related game mechanics, state based AI and pathfinding.\nThe required features for the coursework included:\nCreate a game in which the player must attempt to steal a guarded item from a building inside a voxelised world.","title":"Goat Heist"},{"content":"\u0026lsquo;Paid in Blood\u0026rsquo; was my entry to Trijam #226, a game jam with the twist of being given only three hours to create your game! This does not include planning, compiling or uploading your game, only time spent actively creating the game.\nThe theme for the jam was \u0026lsquo;You gain a little, you lose a little\u0026rsquo;. The idea I settled on for the game was a small roguelite, where the players health is used as a currency to unlock upgrades.\nPlay Game Paid In Blood on Itch.io\nRequired Device: Any device with a mouse and keyboard\nGame Mechanics After clearing a room, the player is given the option to open a chest containing a random permanent power up, at the cost of some health. These upgrades include attack damage, attack speed, fire rate, number of projectiles per shot, and more.\nClearing a room of enemies without taking damage restores a portion of the player\u0026rsquo;s health, rewarding players who are skilled with the opportunity to spend their health points on more upgrades.\nDevelopment Development of this game was of course done over a very short time frame, even moreso than a typical game jam, but heavy use of third party art assets was essential to allow me to finish the game on time.\nThe layout of the map is randomised every time, though each individual room is of course very similar, as the time constraints did not allow too much variation there.\nThe rooms in the level are always connected using a grid like layout, with rooms either being above, below, to the left or right of each other. For each possible configuration of doors in a room, between one and four doors in each position, prefabricated rooms were designed, which would be used to construct a system of interconnected paths around the map.\nThe algorithm used to generate the map works as follows:\nPlace a random room to start\nKeep track of all rooms containing doors without a room to connect to\nGenerate a random compatible room connected to a random available door\nPrioritise generating rooms with more than one door, until the target number of rooms has been reached\nAdd single door rooms to cap off any remaining incomplete paths\nGamejam Results There were 35 entries submitted to the jam, and Paid in Blood was ranked third by user ratings! However, the games in first and second place were not eligible to win, as their creators had gone over the time limit - something which is allowed, but makes you ineligible for first place. Therefore, Paid in Blood was given first place!\nFuture Work Ideas for future work to develop the game further include:\nMore variation in room design, with different layouts and enemy spawns\nA wider variety of possible upgrades such as added projectile effects (ignite enemies, overpenetrate targets etc)\nRare, higher cost chests, with a better chance of giving the player the more powerful upgrades like multi shot\nPotential bad outcomes from opening chests, to add a further element of risk on top of losing health.\nSomething to happen after all rooms are cleared, such as a boss fight.\n","permalink":"https://charliehart.dev/2d/trijam-paid-in-blood-en/","summary":"\u0026lsquo;Paid in Blood\u0026rsquo; was my entry to Trijam #226, a game jam with the twist of being given only three hours to create your game! This does not include planning, compiling or uploading your game, only time spent actively creating the game.\nThe theme for the jam was \u0026lsquo;You gain a little, you lose a little\u0026rsquo;. The idea I settled on for the game was a small roguelite, where the players health is used as a currency to unlock upgrades.","title":"Trijam #226 - Paid in Blood"},{"content":"My undergraduate dissertation project was to create and optimise a voxel based rendering and world generation system. Inspiration for this project was clearly drawn from Minecraft, one of the most popular games of all time, but also from games such as Astroneer - which uses a voxel system at the core of its player destructible world.\nI used Unity for this project, and created a voxel rendering system which was able to generate a set of triangular meshes, with the correct textures applied, to represent an inputted three dimensional array of blocks, which had been generated using smooth noise functions.\nOptimisations were then added to the project, and their impacts were evaluated. It was found that using object pooling for face meshes increased terrain load speeds by an average of 30.7%, and that \u0026lsquo;internal face culling\u0026rsquo; - that is, generating meshes only for block faces deemed to be exposed to the \u0026lsquo;air\u0026rsquo; in the game world - increased frame rates substantially, by over 1,700%, and allowed significantly larger voxel worlds to be rendered.\nPictured: A screenshot of a 112x48x112 voxel world, using the world generation system to create both hills and caves.\nDissertation Dissertation PDF document\nThe dissertation document goes into significantly more detail about this project, many details are omitted in this post to keep it an appropriate length.\nTry It! Dissertation Github Repository - Contains the excecutable project, recorded test data, and the Unity project files, including all written code.\nRequired Device: Windows PC\nRecommended: At least 8GB of RAM, and a dedicated GPU with at least 2GB of VRAM.\nDevelopment Voxel Rendering Each voxel - wether empty or a solid block - has a corresponding Unity gameobject in the respective voxel position within the world, and when a chunk\u0026rsquo;s RenderChunk() function is called, it calls functions within each voxel object to generate the face meshes required to render the scene.\nThen, the correct block material is applied, with each block\u0026rsquo;s material containing 6 textures to be applied, one for each direction on the world\u0026rsquo;s 3D axis, both positive and negative. These textures are stored on a single image, and loaded into memory together, in the same way a sprite atlas may be used for 2D graphics.\nWorld Generation Terrain is generated in a fixed radius around the camera, in a square shape. As the camera moves on either the X or Z axis, more chunks of terrain are generated, and the chunks which are now outside the specified render distance are removed.\nThe world generation algorithm uses a seed to generate worlds, so that the same world could be used when evaluating the effectiveness of optimisations. For each chunk, a set of nested Lists are used to store block information, one for each axis.\nI realise that this is far from optimal, as reading and writing to lists is much slower than using an array, and there will be a significant amount of repeated data here, for example the approximately 50% of the game world consisting of stone blocks. It may be worth investigating ways to optimise this, as terrain generation was significantly slower than I\u0026rsquo;d like it to be.\nAlgorithm Each voxel\u0026rsquo;s position is used as an input to the evaluateBlock() function, which returns the ID of the block which has been generated at that position. This function completes the following steps:\nIf the Y position is 0, a block of lava is generated, so that any generated caves are guaranteed to have solid blocks at the bottom, and are not open to the void.\nThe height of the hills at this position on the X and Z axis is calculated. Perlin noise is sampled here, and is used to interpolate between the given minimum and maximum hill heights in the world config. A Unity AnimationCurve is used to modify the gradient of hills visually inside the Unity editor.\nCaves are generated. Three dimensional Perlin noise is processed by comparing the square of a sampled value to a threshold value, in order to turn the float samples into boolean values. The samples which evaluate to true here are then set to air blocks, carving holes into the game world.\nFuture Work Areas of future work include:\nVariations of block shapes, such as half blocks, ramps, window panes etc.\nVariations of block shading, such as semi transparent blocks like glass, leaves, windows, or water blocks which could add post processing effects to the screen\nA voxel lighting system could be added, such that some blocks could emit light, with the light attenuating over a distance.\nA system to save and import world configurations, so that custom worlds could be displayed, for example a voxel model instead of a naturally generated world.\nAsynchronous terrain generation could be implemented, or the terrain generation could be further optimised, so that the generation of terrain does not cause the game to freeze.\n","permalink":"https://charliehart.dev/3d/voxel-world-diss-en/","summary":"My undergraduate dissertation project was to create and optimise a voxel based rendering and world generation system. Inspiration for this project was clearly drawn from Minecraft, one of the most popular games of all time, but also from games such as Astroneer - which uses a voxel system at the core of its player destructible world.\nI used Unity for this project, and created a voxel rendering system which was able to generate a set of triangular meshes, with the correct textures applied, to represent an inputted three dimensional array of blocks, which had been generated using smooth noise functions.","title":"Voxel Rendering and World Generation System"},{"content":" The Language Game is a multiple choice quiz game made in Unity, inspired partly by the BBC quiz show \u0026ldquo;Richard Osman\u0026rsquo;s House of Games\u0026rdquo;. In the language round of the show, contestants are presented with a multiple choice question, with both the question and all four answers shown in a random foreign language.\nExpanding upon this concept, my game allows the player to also correctly guess the language in which the question is being asked, in order to gain bonus points.\nAs someone with a hobby in linguistics and language learning, I enjoy learning vocabulary and recognising patterns in foreign languages, and so there are 17 different languages available in the game, so that everybody is able to play with a set of languages they are unfamiliar with.\nDownload Google Play Store Page\nRequired Device: Android device running Android 5.1 or higher\nDevelopment Unity Graphs Translation As the game features 17 different playable languages, I had to look elsewhere for translations, for the questions, answers, and localisation in the game.\nI wrote a python script to search through a JSON file containing everything to be translated in English, and use Google\u0026rsquo;s Translate API to retrieve translations for each element.\nQuestions had to be carefully worded, as to remove as much ambiguity as possible, as many phrases do not translate directly into other languages.\nWhere possible, I had friends check the translations in their languages for errors, though some are likely to remain.\nGoogle Play Store In-App Purchases Although this game is free to play, I included an optional one time purchasable \u0026ldquo;Premium Version\u0026rdquo; upgrade for about GBP £2.00, which would disable adverts in game (shown once per 5 or so games), and provide a further 150 or so questions to the player, with more to be added every so often, for free to users who have bought the upgrade.\nI purposefully made the upgrade optional, and opting to play the game for free does not worsen the player experience, and is intended for the few players who really enjoy the game and want more questions, after having played the base game enough to need more questions.\nPublishing This was my first game made for Android, and so I had to go through the developer registration process for the Google Play Store in order to publish the game.\nI also had to create pictures and icons for the game\u0026rsquo;s Play Store page, something I had not done before. I used Canva, as it came with a handful of presets I could use to make a store listing that looked pretty good!\nFuture Work Unity Localisation system For all the menus and UI in the game, I used my own localisation system, reading the name of text objects in the scene, and reading from the language\u0026rsquo;s JSON file to find the string(s) needed. While this does work, it is pretty limited, and cannot replace select substrings with their localised versions. In the future, I\u0026rsquo;d like to explore Unity\u0026rsquo;s localisation system, to see what it offers.\n","permalink":"https://charliehart.dev/2d/language-game-en/","summary":"The Language Game is a multiple choice quiz game made in Unity, inspired partly by the BBC quiz show \u0026ldquo;Richard Osman\u0026rsquo;s House of Games\u0026rdquo;. In the language round of the show, contestants are presented with a multiple choice question, with both the question and all four answers shown in a random foreign language.\nExpanding upon this concept, my game allows the player to also correctly guess the language in which the question is being asked, in order to gain bonus points.","title":"The Language Game"},{"content":"Double-Barrelled Doppelgänger (DBD) was my entry to Mini Jam 117, a 72 hour gamejam that occurs every two weeks on Itch.io. The theme was \u0026lsquo;Ghosts\u0026rsquo;, as the jam took place in October 2022, near halloween.\nThe additional limitation for the jam\u0026rsquo;s entries was \u0026lsquo;Shotgun as a Mechanic\u0026rsquo;, and so DBD features a noisemaker toy shotgun as one of it\u0026rsquo;s core mechanics.\nPlay Game Double-Barreled Doppelgänger on Itch.io\nRequired Device: Windows PC\nGame Mechanics In DBD, you play as a ghost in a haunted mansion. You must escape from a team of ghostbusters who are trying to kill you, and who run towards the player to suck them into their vacuum packs.\nAs the ghost, you have no weapons or tools besides a single toy shotgun, which is able to make loud noises to scare the ghostbusters away, but will not kill them. You also have the ability to turn invisible for a short period of time.\nThe player has to both lure and scare away the ghostbusters, in order to defeat them using environmental hazards such as spikes.\nDevelopment In DBD, there are hidden trigger volumes which cause events to occur, such as torches lighting up to show the player hints as they progress through the levels. In order for this to work, I used UnityActions, a form of delegation in the Unity game engine. Each trigger zone can be assigned a UnityAction to call when the player enters the zone, and this UnityAction can in turn call several functions. This was essential in order to create trigger zones with varying behaviour in the short time frame I had to develop the game.\nRealtime lighting was used in the 2D scenes of the game, so that the player character\u0026rsquo;s torch could be used to explore the levels, and fit the halloween theme. This presented a few challenges, such as ambient lighting. The ambient lighting in the game was originally much brighter, but had to be darkened so that the other light sources in the game cast strong shadows, as this was one of the concepts that I really wanted in the game.\nSo that the player was still visible, a very weak point light was attached to the player, as the cone of light from the torch does not include the player\u0026rsquo;s position.\nGamejam Results 192 entries were submitted to Mini Jam 117, and DBD came in fourth place! Though I had experience working on personal projects before, this was my first time competing in a gamejam, and I was very happy to recieve many positive and constructive reviews from other contestants on Itch.io\n","permalink":"https://charliehart.dev/2d/doppelganger-en/","summary":"Double-Barrelled Doppelgänger (DBD) was my entry to Mini Jam 117, a 72 hour gamejam that occurs every two weeks on Itch.io. The theme was \u0026lsquo;Ghosts\u0026rsquo;, as the jam took place in October 2022, near halloween.\nThe additional limitation for the jam\u0026rsquo;s entries was \u0026lsquo;Shotgun as a Mechanic\u0026rsquo;, and so DBD features a noisemaker toy shotgun as one of it\u0026rsquo;s core mechanics.\nPlay Game Double-Barreled Doppelgänger on Itch.io\nRequired Device: Windows PC","title":"Mini Jam 117- Double-Barrelled Doppelgänger"}]